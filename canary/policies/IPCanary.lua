---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by wangjinshan.
--- DateTime: 2020/08/14 16:21
---
local iputils = require "resty.iputils"
local cjson = require "cjson"
local cache = {}
local BaseCanary = require 'kong.plugins.canary.policies.BaseCanary';

local policy = "ip";
local IPCanary = BaseCanary:new();

function IPCanary:new(o, conf)
  o = o or BaseCanary:new(o, policy, conf)
  setmetatable(o, self);
  self.__index = self;
  return o;
end

local function cidr_cache(cidr_tab)
  local cidr_tab_len = #cidr_tab

  local parsed_cidrs = kong.table.new(cidr_tab_len, 0) -- table of parsed cidrs to return

  -- build a table of parsed cidr blocks based on configured
  -- cidrs, either from cache or via iputils parse
  -- TODO dont build a new table every time, just cache the final result
  -- best way to do this will require a migration (see PR details)
  for i = 1, cidr_tab_len do
    local cidr = cidr_tab[i]
    local parsed_cidr = cache[cidr]

    if parsed_cidr then
      parsed_cidrs[i] = parsed_cidr

    else
      -- if we dont have this cidr block cached,
      -- parse it and cache the results
      local lower, upper = iputils.parse_cidr(cidr)

      cache[cidr] = { lower, upper }
      parsed_cidrs[i] = cache[cidr]
    end
  end
  kong.log.notice('parsed_cidrs:', cjson.encode(parsed_cidrs));
  return parsed_cidrs
end

function IPCanary:validate()
  local binary_remote_addr = ngx.var.binary_remote_addr
  if not self.conf.ip.range or #self.conf.ip == 0 then
    return true, nil;
  end
  return iputils.binip_in_cidrs(binary_remote_addr, cidr_cache(self.conf.ip.range)), self.name;
end

function IPCanary:handler(fallback)

  local binary_remote_addr = ngx.var.binary_remote_addr
  if not self.conf.ip or #self.conf.ip == 0 then
    return 'next', policy
  end
  local ipArray = self.conf.ip
  for i = 1, #ipArray do
    if ipArray[i].range and #ipArray[i].range > 0 then
      if iputils.binip_in_cidrs(binary_remote_addr, cidr_cache(ipArray[i].range)) then
        if ipArray[i].upstream and ipArray[i].upstream.host and ipArray[i].upstream.port then
          kong.service.set_target(ipArray[i].upstream.host,ipArray[i].upstream.port)
          kong.log.notice('Canary policy is ', policy, ',Canary host:', ipArray[i].upstream.host);
          return 'end', policy
        end
      end
    end
  end
  -- uid upstream is not nil
  return 'next', policy
end

return IPCanary
