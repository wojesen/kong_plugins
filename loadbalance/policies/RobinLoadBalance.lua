---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by wangjinshan.
--- DateTime: 2020/8/11 10:18
---

local pl_stringx = require "pl.stringx"
local print = print
local tconcat = table.concat
local tinsert = table.insert
local srep = string.rep
local type = type
local pairs = pairs
local tostring = tostring
local next = next

function print_r(root)
  local cache = {  [root] = "." }
  local function _dump(t,space,name)
    local temp = {}
    for k,v in pairs(t) do
      local key = tostring(k)
      if cache[v] then
        tinsert(temp,"+" .. key .. " {" .. cache[v].."}")
      elseif type(v) == "table" then
        local new_key = name .. "." .. key
        cache[v] = new_key
        tinsert(temp,"+" .. key .. _dump(v,space .. (next(t,k) and "|" or " " ).. srep(" ",#key),new_key))
      else
        tinsert(temp,"+" .. key .. " [" .. tostring(v).."]")
      end
    end
    return tconcat(temp,"\n"..space)
  end
  print(_dump(root, "",""))
end


local cjson = require "cjson"
local random = math.random
local BaseLoadBalance = require 'kong.plugins.loadbalance.policies.BaseLoadBalance';
local policy = 'robin'

-- calculate the greater common divisor, used to find the smallest wheel
-- possible
local function gcd(a, b)
  if b == 0 then
    return a
  end

  return gcd(b, a % b)
end

local function wheel_shuffle(wheel)
  for i = #wheel, 2, -1 do
    local j = random(i)
    wheel[i], wheel[j] = wheel[j], wheel[i]
  end
  return wheel
end

local RobinLoadBalance = BaseLoadBalance:new()
function RobinLoadBalance:new(o, conf)
  o = o or BaseLoadBalance:new(o, policy, conf)
  setmetatable(o, self);
  self.__index = self;
  self.pointer = ngx.shared["test"]
  if self.pointer == nil then
    print_r({"wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww"})
  end
  print_r({self.pointer})
  print_r({"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"})
  self.pointer = 1;
  self.wheelSize = 0;
  --self.maxWheelSize = balancer.maxWheelSize or balancer.wheelSize or MAX_WHEEL_SIZE;
  self.wheel = {};
  print_r({"ooooooooooooooooooooooooooooooo"})
  self:afterHostUpdate()
  return o;
end

function RobinLoadBalance:afterHostUpdate()
  local new_wheel = {}
  local total_points = 0
  local total_weight = 0
  local divisor = 0
  local upstreams = self.conf.loadbalance_upstream

  for i = 1, #upstreams do
    print_r({"hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh"})
    print_r(upstreams[i])
    print_r({"iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii"})
    local address_weight = upstreams[i].weight
    divisor = gcd(divisor, address_weight)
    total_weight = total_weight + address_weight
  end

  --self.balancer.totalWeight = total_weight
  if total_weight == 0 then
    ngx.log(ngx.DEBUG, "trying to set a round-robin balancer with no addresses")
    return
  end

  if divisor > 0 then
    total_points = total_weight / divisor
  end

  -- add all addresses to the wheel
  for i = 1, #upstreams do
    print_r({"hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh"})
    print_r(upstreams[i])
    print_r({ divisor })
    print_r({"iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii"})
    local address_points = upstreams[i].weight / divisor
    print_r({"gggggggggggggggggggggggggggggggggggggg"})
    print_r({ address_points })
    for _ = 1, address_points do
      new_wheel[#new_wheel + 1] = upstreams[i]
    end
    print_r({"mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm"})
    print_r(new_wheel)
  end

  -- store the shuffled wheel
  self.wheel = wheel_shuffle(new_wheel)
  self.wheelSize = total_points
end


function RobinLoadBalance:validate()
  return true, self.name
end

function RobinLoadBalance:get_upstream()




  local starting_pointer = self.pointer
  print_r({"dddddddddddddddddddddddddddd"})
  print_r({self.pointer})
  print_r({"eeeeeeeeeeeeeeeeeeeeeeeeee"})
  print_r({self.wheelSize})
  print_r({"ffffffffffffffffffffffffffffff"})
  print_r(self.wheel)
  print_r({"ggggggggggggggggggggggggggggggg"})
  local address
  local ip, port, hostname
  repeat
    self.pointer = self.pointer + 1

    if self.pointer > self.wheelSize then
      self.pointer = 1
    end

    local upstream = self.wheel[self.pointer]
    if upstream ~= nil  then
      print_r({"xxxxxxxxxxxxxxxxxxxxxxxxxxx"})
      print_r({ upstream.host })
      print_r({ upstream.port })
      print_r({"yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy"})
      return upstream.host,upstream.port

    end

  until self.pointer == starting_pointer


  --if upstreams and #upstreams>0 then
  --  if #upstreams == 1 then
  --    return upstreams[1].host,upstreams[1].port
  --  else
  --    local count = math.random(100)
  --    for i = 1, #upstreams do
  --      if upstreams[i].weight and upstreams[i].weight > 0 then
  --        if upstreams[i].weight>count then
  --          return upstreams[i].host,upstreams[i].port
  --        else
  --          count = count - upstreams[i].weight
  --        end
  --      end
  --    end
  --    return upstreams[1].host,upstreams[1].port
  --  end
  --end
  return nil;
end

function RobinLoadBalance:handler(fallback)
  print_r({"ppppppppppppppppppppppppppppppppppp"})
  print_r({self.pointer})
  print_r({"qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq"})
  local validate, policy_loadbalance = self:validate();

  -- false fallback default upstream
  if not validate then
    fallback();
    return 'fallback', policy_loadbalance
  end
  -- uid upstream is not nil
  local _host,_port = self:get_upstream()
  if _host and _port then
    kong.service.set_target(_host,_port)
    kong.log.notice('loadbalance policy is ', policy_loadbalance, ',loadbalance host:', _host);
    return 'end', policy_loadbalance
  end
end

return RobinLoadBalance
